diff --git a/node_modules/@letta-ai/letta-code/letta.js b/node_modules/@letta-ai/letta-code/letta.js
index a74d551..459f60b 100755
--- a/node_modules/@letta-ai/letta-code/letta.js
+++ b/node_modules/@letta-ai/letta-code/letta.js
@@ -65184,10 +65184,12 @@ ${SYSTEM_REMINDER_CLOSE}
             return { stopReason: "error", shouldAccumulate: true };
           }
           if (updatedApproval && !autoApprovalEmitted.has(updatedApproval.toolCallId)) {
+            if (process.env.DEBUG_SDK) console.error(`[CLI-StreamHook] updatedApproval: tool=${updatedApproval.toolName} callId=${updatedApproval.toolCallId} argsLen=${(updatedApproval.toolArgs || '').length}`);
             const { autoAllowed } = await classifyApprovals([updatedApproval], {
               requireArgsForAutoApprove: true,
               missingNameReason: "Tool call incomplete - missing name"
             });
+            if (process.env.DEBUG_SDK) console.error(`[CLI-StreamHook] classifyApprovals: allowed=${autoAllowed.length}`);
             const [approval] = autoAllowed;
             if (approval) {
               const permission = approval.permission;
@@ -65238,6 +65240,7 @@ ${SYSTEM_REMINDER_CLOSE}
         lastRunId = result.lastRunId || null;
         if (lastRunId)
           lastKnownRunId = lastRunId;
+        if (process.env.DEBUG_SDK) console.error(`[CLI-Headless] Stream drained: stopReason=${stopReason} approvals=${approvals.length} runId=${lastRunId}`);
       } else {
         const result = await drainStreamWithResume(stream2, buffers, () => {});
         stopReason = result.stopReason;
@@ -65258,6 +65261,12 @@ ${SYSTEM_REMINDER_CLOSE}
         break;
       }
       if (stopReason === "requires_approval") {
+        if (process.env.DEBUG_SDK) {
+          console.error(`[CLI-Headless] requires_approval: ${approvals.length} approval(s) pending`);
+          for (const a of approvals) {
+            console.error(`[CLI-Headless]   tool=${a.toolName} callId=${a.toolCallId} argsLen=${(a.toolArgs || '').length}`);
+          }
+        }
         if (approvals.length === 0) {
           console.error("Unexpected empty approvals array");
           process.exit(1);
@@ -65268,6 +65277,15 @@ ${SYSTEM_REMINDER_CLOSE}
           requireArgsForAutoApprove: true,
           missingNameReason: "Tool call incomplete - missing name"
         });
+        if (process.env.DEBUG_SDK) {
+          console.error(`[CLI-Headless] classifyApprovals: allowed=${autoAllowed.length} denied=${autoDenied.length}`);
+          for (const a of autoAllowed) {
+            console.error(`[CLI-Headless]   ALLOW: tool=${a.approval.toolName} rule=${a.permission.matchedRule || a.permission.reason}`);
+          }
+          for (const a of autoDenied) {
+            console.error(`[CLI-Headless]   DENY: tool=${a.approval.toolName} reason=${a.denyReason || a.permission.reason}`);
+          }
+        }
         const decisions = [
           ...autoAllowed.map((ac) => ({
             type: "approve",
@@ -65282,8 +65300,10 @@ ${SYSTEM_REMINDER_CLOSE}
             };
           })
         ];
+        if (process.env.DEBUG_SDK) console.error(`[CLI-Headless] Executing ${decisions.length} approval decisions...`);
         const { executeApprovalBatch: executeApprovalBatch2 } = await init_approval_execution().then(() => exports_approval_execution);
         const executedResults = await executeApprovalBatch2(decisions);
+        if (process.env.DEBUG_SDK) console.error(`[CLI-Headless] Approval batch executed: ${executedResults.length} results`);
         currentInput = [
           {
             type: "approval",
